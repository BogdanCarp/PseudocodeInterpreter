program: (NL | stmt)* EOF

stmt: simple_stmt | comp_stmt
simple_stmt: small_stmt NL
small_stmt: expr_stat | flow_stat
flow_stat: break_stat | continue_stat | return_stat

break_stmt: BREAK
continue_stmt: CONTINUE
return_stmt: RETURN test

comp_stmt: if_stmt | while_stmt | until_stmt | times_stmt | funcdef
if_stmt: IF test THEN NL suite NL (ELSEIF test THEN NL suite NL)* [ELSE NL suite] NL end NL
while_stmt: WHILE test DO NL suite NL END NL
until_stmt: UNTIL test DO NL suite NL END NL
times_stmt: test TIMES DO NL suite NL END NL
suite: stmt+

test: or_test [IF or_test ELSE test]
or_test: and_test (OR and_test)*
and_test: not_test (AND not_test)*
not_test: NOT not_test | comparison

comparison: expr (comp_op expr)*
comp_op: LESS LESSEQUAL GREATER GREATEREQUAL EQUAL NOTEQUAL IN NOTIN
expr: xor_expr (BITOR xor_expr)*
xor_expr: and_expr (XOR and_expr)*
and_expr: shift_expr (BITAND shift_expr)*
shift_expr: arith_expr ((SHIFTL | SHIFTR) arith_expr)*
arith_expr: term ((PLUS | MINUS) term)
term: factor ((MULT | DIV | MOD | DIVINT) factor)*
factor: (PLUS | MINUS | BITNEG) factor | power
power: atom_expr [POW factor]

# ex: [2, 3, 4].length  or  add(1, 2)   or  [1, 2, 3, 4, 5, 6][1:3]
atom_expr: atom trailer*

# 1. array literal 2. another test in parantheses ...
atom: LSQUBRA [testlist] RSQUBRA | LPAR test RPAR | IDENTIFIER | NUMBERLIT | TEXTLIT | NULL | TRUE | FALSE
testlist: test(COMMA test)* [COMMA]

# function add (integer a, integer b) -> integer
#   return a + b
# end
funcdef: FUNC IDENTIFIER formal_params [RETURN_ARROW type] NL suite NL end NL
formal_params: LPAR (type IDENTIFIER)* RPAR

# 1. function parameters 2. array slicing 3. type member
trailer: LPAR [testlist] RPAR | LSQUBRA subscript RSQUBRA | DOT IDENTIFIER

subscript: test | [test] COLON [test] [sliceop]
sliceop: COLON [test]

expr_stmt: test | vardecl | varassign
vardecl: type (IDENTIFIER [ASSIGN test])+
varassign: IDENTIFIER ASSIGN test

type: NUMBER | TEXT | BOOL

###############################################################
# Tokens (using other kind of regex notation dunno the names) #
###############################################################

NL: '\n'
PLUS: '+'
MINUS: '-'
MULT: '*'
DIV: '/'
DIVINT: '//'
MOD: '%'
POW: '**'
LPAR: '('
RPAR: ')'
LSQUBRA: '['
RSQUBRA: ']'
COLON: ':'
DOT: '.'
BITOR: '|'
XOR: '^'
BITAND: '&'
BITNEG: '~'
SHIFTL: '<<'
SHIFTR: '>>'
LESS: '<'
LESSEQUAL: '<='
GREATER: '>'
GREATEREQUAL: '>=' 
EQUAL: '=='
NOTEQUAL: '!='
ASSIGN: '='

NUMBERLIT: /[0-9]+(?:\.[0-9]*)?/
TEXTLIT: /"(?:[^"\\]|\\.)*"/
IDENTIFIER: /[a-zA-Z][a-zA-Z0-9]+/ BUT SOMETIMES CAN BE /[a-zA-Z][a-zA-Z0-9]+ [a-zA-Z]/

BREAK
CONTINUE
RETURN
IF
THEN
ELSEIF
ELSE
WHILE
UNTIL
TIMES
DO
END
FUNCTION
AND
OR
TRUE
FALSE